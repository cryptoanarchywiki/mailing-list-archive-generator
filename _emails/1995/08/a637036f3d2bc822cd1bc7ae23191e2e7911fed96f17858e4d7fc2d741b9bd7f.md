---
layout: default
---

# 1995-08-08 - proving programs correct

## Header Data

From: "Perry E. Metzger" \<perry@panix.com\><br>
To: cypherpunks@toad.com<br>
Message Hash: a637036f3d2bc822cd1bc7ae23191e2e7911fed96f17858e4d7fc2d741b9bd7f<br>
Message ID: \<199508081248.IAA11447@panix2.panix.com\><br>
Reply To: _N/A_<br>
UTC Datetime: 1995-08-08 12:48:32 UTC<br>
Raw Date: Tue, 8 Aug 95 05:48:32 PDT<br>

## Raw message

```
{% raw  %}From: "Perry E. Metzger" <perry@panix.com>
Date: Tue, 8 Aug 95 05:48:32 PDT
To: cypherpunks@toad.com
Subject: proving programs correct
Message-ID: <199508081248.IAA11447@panix2.panix.com>
MIME-Version: 1.0
Content-Type: text/plain



A boss of mine at Bellcore, and a very smart guy (B. Gopinath) once
mentioned to me that (with the exception of scheme) he'd never seen a
set of formal semantics for a language that were smaller than the
largest program one would care to write in the language. He was, of
course, slightly exagerating for effect, but his point was very
simple: you can't even get the basis on which to write your proofs
right.

An interesting experience happened during the same project, as I
recall: we attempted to prove a small bit of code correct.
Unfortunately, the proof had a bug in it which meshed nicely with a
bug in the program and a bug in the implementation. Proofs are no less
large complicated formal constructs than programs are, and checking
them is no less onerous, unless they are written in formal logic in
which case they are not possible for human beings to produce.

Perry




{% endraw %}
```

## Thread

+ Return to [August 1995](/archive/1995/08)

+ 1995-08-08 (Tue, 8 Aug 95 05:48:32 PDT) - proving programs correct - _"Perry E. Metzger" \<perry@panix.com\>_
  + 1995-08-08 (Tue, 8 Aug 95 10:55:49 PDT) - [Re: proving programs correct](/archive/1995/08/eccb215a2f3902b554467cb5d3cc422d8743fca1fb37b0384f63a264a6e22e4a) - _hallam@w3.org_

