---
layout: default
---

# 1994-07-12 - Security for under a buck fifty

## Header Data

From: Ben Goren \<ben<span>@</span>Tux.Music.ASU.Edu\><br>
To: cypherpunks@toad.com<br>
Message Hash: daf3d3ea1b8e04becab8debefa2dcf5cef3526495a57a3217e9be1d2cb3709d9<br>
Message ID: \<Pine.3.89.9407112119.A22909-0100000@Tux.Music.ASU.Edu\><br>
Reply To: _N/A_<br>
UTC Datetime: 1994-07-12 04:09:48 UTC<br>
Raw Date: Mon, 11 Jul 94 21:09:48 PDT<br>

## Raw message

```
{% raw  %}From: Ben Goren <ben@Tux.Music.ASU.Edu>
Date: Mon, 11 Jul 94 21:09:48 PDT
To: cypherpunks@toad.com
Subject: Security for under a buck fifty
Message-ID: <Pine.3.89.9407112119.A22909-0100000@Tux.Music.ASU.Edu>
MIME-Version: 1.0
Content-Type: text/plain


The dilemma with the pass phrase issue seems to boil down to the
balance between entropy and memorability.

The "shocking nonsense" guidelines sound like about the best
suggestions I've heard for humans to generate pass phrases, but I
would suggest that even shocking nonsense can be broken by
somebody--or something--that thinks like Charles Dodgson. If it came
from a process that includes any logic at all, that logic will be
discovered if economical to an attacker.

But who can remember a 132-bit true random number? Take, for example:

0X997D6C32FC8F99104FDCC8BF4B24C7031

I got that number by grabbing handfuls of pennies out of a pile of
132--a true random number generator that cots less than
breakfast--though, I will admit that it's somewhat cumbersome.

But a number can be represented in many different ways. Create a
six-bit character set, filling from 000000 to 111111 with a-z, A-Z,
0-9, . [period], and - [hyphen]. Now, the key becomes:

Mx1SmVYpMrbp3mI-sYthaX

Not impressed yet? Try using the human brain's wonderful talent for
seeing patterns in randomness. If your mind just happened to work
exactly like mine, you would get:

Mx1 misSiles moVe Yp; Mr. bop of 3m I-s Yt haX. [Yt as in the
element.]

I would suggest that it would only take the average person a minute
or two to memorize such a phrase, especially if she were the one to
do the pattern-matching in the first place.

So, the end result is a ten-word pass phrase that isn't hard to
learn, is only vulnerable to a brute-force attack, and would take
about a sextillion years to brute-force at a trillion encrypts per
second--and the universe is "only" a hundred billion years old.

Can anybody suggest how to implement this? Can a computer program
suggest mnemonics that would mean anything to a person? Even if the
computer gives the user a screenful of such? Or, how about giving a
screenful of "words," and letting the user mix-n-match?

Obviously, you would need a real random number generator and a
secure terminal for all this.

Maybe it's time for me to write some code....

b&

--
Ben.Goren@asu.edu, Arizona State University School of Music
 net.proselytizing (write for info): Protect your privacy; oppose Clipper.
 Voice concern over proposed Internet pricing schemes. Stamp out spamming.
 Finger ben@tux.music.asu.edu for PGP 2.3a public key.




{% endraw %}
```

## Thread

+ Return to [July 1994](/archive/1994/07)

+ Return to "[Ben Goren <ben<span>@</span>Tux.Music.ASU.Edu>](/authors/ben_goren_ben_at_tux_music_asu_edu_)"
+ Return to "[Mike Johnson second login <exabyte!gedora!mikej2<span>@</span>uunet.uu.net>](/authors/mike_johnson_second_login_exabytegedoramikej2_at_uunet_uu_net_)"

+ 1994-07-12 (Mon, 11 Jul 94 21:09:48 PDT) - Security for under a buck fifty - _Ben Goren \<ben@Tux.Music.ASU.Edu\>_
  + 1994-07-12 (Tue, 12 Jul 94 09:46:14 PDT) - [Re: Security for under a buck fifty](/archive/1994/07/bb448331def48f0698073f12cd13d74660213762a8548efac93a17ce3c148c39) - _Mike Johnson second login \<exabyte!gedora!mikej2@uunet.uu.net\>_

