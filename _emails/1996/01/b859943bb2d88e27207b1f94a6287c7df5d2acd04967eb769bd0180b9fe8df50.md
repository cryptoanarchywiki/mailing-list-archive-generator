---
layout: default
---

# 1996-01-07 - Re: "trust management" vs. "certified identity"

## Header Data

From: Matt Blaze \<mab@research.att.com\><br>
To: "Frank O'Dwyer" \<fod@brd.ie\><br>
Message Hash: b859943bb2d88e27207b1f94a6287c7df5d2acd04967eb769bd0180b9fe8df50<br>
Message ID: \<199601070103.UAA13065@nsa.tempo.att.com\><br>
Reply To: \<01BADC99.C7034FE0@dialup-169.dublin.iol.ie\><br>
UTC Datetime: 1996-01-07 01:13:47 UTC<br>
Raw Date: Sun, 7 Jan 1996 09:13:47 +0800<br>

## Raw message

```
{% raw  %}From: Matt Blaze <mab@research.att.com>
Date: Sun, 7 Jan 1996 09:13:47 +0800
To: "Frank O'Dwyer" <fod@brd.ie>
Subject: Re: "trust management" vs. "certified identity"
In-Reply-To: <01BADC99.C7034FE0@dialup-169.dublin.iol.ie>
Message-ID: <199601070103.UAA13065@nsa.tempo.att.com>
MIME-Version: 1.0
Content-Type: text/plain


...
>That's not to say that the certification approach can't be general, though.  
>It occurred to me that a very general certificate format would
>simply be to sign some assertions (predicates), and then 
>feed all available signed predicates plus some axioms (the analogue 
>of root keys) into a theorem prover.  Sounds slow though.  More 
>practically perhaps, you could sign some kind of (safe) interpreted code, 
>and have the verifier execute it on some initial variable set to come up with
>some access decision.  
>
Yes.  That's pretty much PolicyMaker in a nutshell.

-matt




{% endraw %}
```

## Thread

+ Return to [January 1996](/archive/1996/01)

+ 1996-01-07 (Sun, 7 Jan 1996 09:07:26 +0800) - [RE: "trust management" vs. "certified identity"](/archive/1996/01/bb096d6d8a08e3fcaaca7dea24843a7fe5dd611168f837b268c96d26d27697df) - _"Frank O'Dwyer" \<fod@brd.ie\>_
  + 1996-01-07 (Sun, 7 Jan 1996 09:13:47 +0800) - Re: "trust management" vs. "certified identity" - _Matt Blaze \<mab@research.att.com\>_

