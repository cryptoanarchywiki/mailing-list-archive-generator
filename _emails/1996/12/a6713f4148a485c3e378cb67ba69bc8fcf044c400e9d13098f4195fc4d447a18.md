---
layout: default
---

# 1996-12-20 - Re: Executing Encrypted Code

## Header Data

From: Jazzmin Belle Sommers \<jazzmin<span>@</span>ou.edu\><br>
To: cypherpunks@toad.com<br>
Message Hash: a6713f4148a485c3e378cb67ba69bc8fcf044c400e9d13098f4195fc4d447a18<br>
Message ID: \<32bad01e16c5002@cliff.ou.edu\><br>
Reply To: _N/A_<br>
UTC Datetime: 1996-12-20 19:38:49 UTC<br>
Raw Date: Fri, 20 Dec 1996 11:38:49 -0800 (PST)<br>

## Raw message

```
{% raw  %}From: Jazzmin Belle Sommers <jazzmin@ou.edu>
Date: Fri, 20 Dec 1996 11:38:49 -0800 (PST)
To: cypherpunks@toad.com
Subject: Re: Executing Encrypted Code
Message-ID: <32bad01e16c5002@cliff.ou.edu>
MIME-Version: 1.0
Content-Type: text/plain



>>>> You could also timestamp the software so that it only runs for a given
>>>> length of time.  This will encourage people to upgrade regularly.  ;-)

>>> Or to reset their clocks. Which is what many of us do when software is
>>> about to "expire."

>>However, why not use "beacons"?  

chop chop chop

I have been using some shareware that simply has a built-in counter.  Once
the counter runs out, you have to register.  I would suppose that one could
hack the code to find the counter, assuming you could decompile it (or
wanted to).

Personally I think this is a decent solution to the problem -- the counter
on this particular software let you use it 50 times.  That's adequate to
determine whether you want to keep it or not.

Of course, if you saved the .zip file to disk before you installed it, you
could delete the copy and reinstall the .zip.  But everyone knows this.

Jazzmin Sommers






{% endraw %}
```

## Thread

+ Return to [December 1996](/archive/1996/12)

+ Return to "[Jazzmin Belle Sommers <jazzmin<span>@</span>ou.edu>](/author/jazzmin_belle_sommers_jazzmin_at_ou_edu_)"

+ 1996-12-20 (Fri, 20 Dec 1996 11:38:49 -0800 (PST)) - Re: Executing Encrypted Code - _Jazzmin Belle Sommers \<jazzmin@ou.edu\>_

