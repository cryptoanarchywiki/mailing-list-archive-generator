---
layout: default
---

# 1993-05-19 - false positives

## Header Data

From: baumbach@atmel.com (Peter Baumbach)<br>
To: cypherpunks@toad.com<br>
Message Hash: 20ccb870f4a49503c1855d42c4b7cc29612ecb89d8d085896e11c61acec0f0bb<br>
Message ID: \<9305192112.AA04939@carp.chp.atmel.com\><br>
Reply To: _N/A_<br>
UTC Datetime: 1993-05-19 21:51:49 UTC<br>
Raw Date: Wed, 19 May 93 14:51:49 PDT<br>

## Raw message

```
{% raw  %}From: baumbach@atmel.com (Peter Baumbach)
Date: Wed, 19 May 93 14:51:49 PDT
To: cypherpunks@toad.com
Subject: false positives
Message-ID: <9305192112.AA04939@carp.chp.atmel.com>
MIME-Version: 1.0
Content-Type: text/plain


I have an encryption question:

Has anyone tried to create a strong encryption algorithm that cannot
be broken by brute force?  If the algorithm relied on a dictionary,
for instance, then the wrong key could still return something that
resembles english.  It would be even better if for any arbitrary text,
a KEY could be generated which maps the encrypted real message to
the arbitrary text.  

With this system, even if your true key could be figured out (maybe
you wrote it on a napkin!), you could easely deny the accuracy of
the decryption.  A decrypted message would only be useful for
information, but never for evidence.  

This is more of an idea than a question.  What do you think?

In liberty,

Peter Baumbach
baumbach@atmel.com




{% endraw %}
```

## Thread

+ Return to [May 1993](/archive/1993/05)

+ 1993-05-19 (Wed, 19 May 93 14:51:49 PDT) - false positives - _baumbach@atmel.com (Peter Baumbach)_
  + 1993-05-19 (Wed, 19 May 93 15:45:18 PDT) - [Re: false positives](/archive/1993/05/9e05899b24c94fc7972ef1d76c47d0a2e33a46dfb31418f990be0090079d1f64) - _Marc Horowitz \<marc@GZA.COM\>_

